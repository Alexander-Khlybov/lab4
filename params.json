{
  "name": "Lab4",
  "tagline": "",
  "body": "#Реализация приоритетной очереди на основе различных структур данных и ее применение для построения остовного дерева графа с помощью алгоритма Крускала\r\n\r\n***\r\n\r\n## Содержание\r\n\r\n* [Постановка задачи](#Постановка-задачи)\r\n* [Руководство пользователя](#Руководство-пользователя)\r\n\t* [Использование реализации алгоритма Дейкстры](#Использование-реализации-алгоритма-Дейкстры)\r\n\t* [Использование реализации алгоритма Крускала](#Использование-реализации-алгоритма-Крускала)\r\n* [Руководство программиста](#Руководство-программиста)\r\n\t* [Используемые технологии](#Используемые-технологии)\r\n\t* [Общая структура репозитория](#Общая-структура-репозитория)\r\n\t* [Описание структуры решения](#Описание-структуры-решения)\r\n\t* [Описание структур данных](#Описание-структур-данных)\r\n\t\t* [D-куча](#D-куча)\r\n\t\t* [Бинарное дерево](#Бинарное-дерево)\r\n\t\t\t* [Бинарное поисковое дерево](#Бинарное-поисковое-дерево)\r\n\t\t\t* [АВЛ-дерево](#АВЛ-дерево)\r\n\t\t* [Таблицы](#Таблицы)\r\n\t\t\t* [Просматриваемые таблицы](#Просматриваемые-таблицы)\r\n\t\t\t* [Упорядоченные таблицы](#Упорядоченные-таблицы)\r\n\t\t* [Приоритетная очередь](#Приоритетная-очередь)\r\n\t\t* [Разделенные множества](#Разделенные-множества)\r\n\t* [Описание алгоритмов](#Описание-алгоритмов)\r\n\t\t* [Пирамидальная сортировка](#Пирамидальная-сортировка)\r\n\t\t* [Алгоритм Дейкстры](#Алгоритм-Дейкстры)\r\n\t\t* [Алгоритм Крускала](#Алгоритм-Крускала)\r\n\t* [Программная реализация структур данных](#Программная-реализация-структур-данных)\r\n\t\t* [Программная реализация d-кучи](#Программная-реализация-d-кучи)\r\n\t\t* [Программая реализация бинарного поискового дерева](#Программая-реализация-бинарного-поискового-дерева)\r\n\t\t* [Программая реализация АВЛ-дерева](#Программая-реализация-АВЛ-дерева)\r\n\t\t* [Программая реализация просматриваемых таблиц](#Программая-реализация-просматриваемых-таблиц)\r\n\t\t* [Программая реализация упорядоченных таблиц](#Программая-реализация-упорядоченных-таблиц)\r\n\t\t* [Программая реализация приоритетной очереди](#Программая-реализация-приоритетной-очереди)\r\n\t\t* [Программая реализация разделенных множеств](#Программая-реализация-разделенных-множеств)\r\n\t* [Представление графа](#Представление-графа)\r\n* [Заключение](#Заключение)\r\n* [Литература](#Литература)\r\n\r\n##Постановка задачи\r\n\r\n1. Разработать статичесие библиотеки, реализующие слудующие структуры данных:\r\n\t* d-куча;\r\n\t* бинарное поисковое дерево;\r\n\t* авл-сбалансированное дерево;\r\n\t* просматриваемая таблица;\r\n\t* упорядоченная таблица;\r\n\t* приоритетная очередь, основанная на d-куче;\r\n\t* приоритетная очередь, основанная на бинарном сбалансированном дереве;\r\n\t* приоритетная очередь, основанная на упорядоченной таблице;\r\n\t* разделенные множества.\r\n2. Написать тестирующую программу для каждой структуры данных с помощью Google C++ Testing Framework.\r\n3. Написать приложение для демонстрации работы d-кучи (пирамидальная сортировка).\r\n4. Написать приложение для демонстрации работы приоритетной очереди, основанной на d-куче (алгоритм Дейкстры):\r\n\t* входные данные - связный неориентированный взвешенный граф без петель со стартовой вершиной;\r\n\t* выходные данные - список расстояний до каждой вершины графа;\r\n5. Написать приложение для демонстрации работы каждой приоритетной очереди и разделенных множеств (алгоритм Крускала):\r\n\t* входные данные - связный неориентированный взвешенный граф без петель;\r\n\t* выходные данные - граф, представляющий минимальное остовное дерево для исходного графа.\r\n\r\n##Руководство пользователя\r\n\r\n###Использование реализации алгоритма Дейкстры\r\n\r\n####Запуск приложения и ввод данных\r\n\r\nПрограмма предназначена для поиска кратчийших путей во взвешенном неориентированном графе от некоторой вершины, называемой текущей, до всех остальных вершин графа.\r\nДля запуска приложения нужно открыть исполняемый файл `sample_Dijkstra.exe`.\r\nПрограмма попросит ввести количество вершин графа и ребра с весом. Также будет запрошен номер вершины, являющейся стартовой. Результатом будет вывод вектора, содержащего номера вершин, что предшествуют вершинам, являющимся индексами вектора, для построения дерева, позволяющего восстановить обход и вывод списка расстояний от стартовой вершины до каждой из следующих вершин в порядке возрастания номера.\r\n\r\n####Пример:\r\n\r\nРассмотрим граф:\r\n\r\n![graph](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph.png)\r\n\r\nДля рассматриваемого графа алгоритм считает расстояния от вершины №1 до всех остальных вершин (ребра, через которые проходит кратчайший путь до вершины, помечены цветом этой вершины):\r\n\r\n![graph_Dijkstra](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph_Dijkstra.png)\r\n\r\n#####Шаг 1\r\nВвод количества вершин графа\r\n\r\n![Dijkstra1](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra1.png)\r\n\r\n#####Шаг 2\r\nВвод ребер и их весов\r\n\r\n![Dijkstra2](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra2.png)\r\n\r\n#####Шаг 3\r\nВыбор стартовой вершины\r\n\r\n![Dijkstra3](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra3.png)\r\n\r\n#####Шаг 4\r\nВывод результата и завершение работы программы\r\n\r\n![Dijkstra4](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra4.png)\r\n\r\n###Использование реализации алгоритма Крускала\r\n\r\n####Запуск приложения и ввод данных\r\n\r\nПрограмма предназначена для построения минимального остовного дерева для взвешенного неориентированного графа. \r\nДля запуска приложения нужно открыть исполняемый файл `sample_Kruskal.exe`.\r\nПрограмма попросит ввести количество вершин графа и ребра с весом. Результатом работы программы будет вывод списка ребер, составляющих минимальное остовное дерево.\r\n\r\n####Пример\r\n\r\nРассмотрим граф:\r\n\r\n![graph](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph.png)\r\n\r\nДля рассматриваемого графа алгоритм строит дерево, выделенное зеленым цветом:\r\n\r\n![graph_Kruskal](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph_Kruskal.png)\r\n\r\n#####Шаг 1\r\nВвод количества вершин графа\r\n\r\n![Kruskal1](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal1.png)\r\n\r\n#####Шаг 2\r\nВвод ребер и их весов\r\n\r\n![Kruskal2](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal2.png)\r\n\r\n#####Шаг 3\r\nВыбор базы для приоритетной очереди\r\n\r\n![Kruskal3](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal3.png)\r\n\r\n#####Шаг 4\r\nВывод результата и завершение работы программы\r\n\r\n![Kruskal4](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal4.png)\r\n\r\n##Руководство программиста\r\n\r\n###Используемые технологии\r\n- среда разработки Microsoft Visual Studio Community (2015);\r\n- фреймворк для написания автоматических тестов Google Test;\r\n- система контроля версий Git.\r\n\r\n###Общая структура репозитория\r\n* [`gtest`](https://github.com/Alexander-Khlybov/lab4/tree/master/gtest) - библиотека GoogleTest.\r\n* [`src`](https://github.com/Alexander-Khlybov/lab4/tree/master/src) - директория для размещения файлов исходноо кода.\r\n* [`include`](https://github.com/Alexander-Khlybov/lab4/tree/master/include) - директория для размещения заголовочных файлов.\r\n* [`sample`](https://github.com/Alexander-Khlybov/lab4/tree/master/samples) - директория для размещения исходных кодов приложений.\r\n* [`test`](https://github.com/Alexander-Khlybov/lab4/tree/master/test) - директория для размещения тестов.\r\n* [`sln`](https://github.com/Alexander-Khlybov/lab4/tree/master/sln/) - директория с файлими решений (на данный момент Visual Studio 2015).\r\n* [`Rept`](https://github.com/Alexander-Khlybov/lab4/tree/master/Rept) - директория с материалами для отчета;\r\n* Служебные файлы:\r\n  * `.gitignore` - перечень расширений файлов, игнорируемых Git при добавлении файлов в репозиторий.\r\n\r\n###Описание структуры решения\r\nРешение состоит из 13 проектов:\r\n\r\n* `gtest` - фреймворк Google Test;\r\n* `d-heap_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса D_HEAP.\r\n* `disjoint-set_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса DISJOINT_SET.\r\n* `binary_search_tree_lib` - статическая библиотка, содержащая объявление и реализацию класса *BST*.\r\n* `avl-tree_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса *AVL_TREE*.\r\n* `tables_lib` - статическая библиотека, содержащая объявление и реализацию шаблонных классов *TABLE*, *SCAN_TABLE*, *SORT_TABLE*.\r\n* `graph_lib` - статическая библиотека, содержащая объявление и реализацию класса *GRAPH*.\r\n* `priority_queue_lib` - статическая библиотека, содержащая объявление и реализацию шаблонных классов приоритетных очередей, основанных на разных структурах данных.\r\n* `algorithms` - статическая библиотека, содержащая объявление и реализацию алгоритмов для примеров.\r\n* `sampleDijkstra` - консольное приложение для демонстрации работы алгоритма Дейкстры.\r\n* `sample_Kruskal` - консольное приложение для демонстрации работы алгоритма Крускала.\r\n* `sample_d-heap` - консольное приложение для демонстрации работы пирамидальной сортировки.\r\n* `test` - консольно приложение для проверки правильности реализации классов *D_HEAP*, *PRIORITY_QUEUE*, *DISJOINT_SET*.\r\n\r\n###Описание структур данных\r\n\r\n####D-куча\r\n\r\nD-куча - завершенное d-арное дерево, содержащее набор однотипных элементов, со следующими свойствами:\r\n- Каждый узел, не являющийся листом, за исключением, быть может, одного имеет ровно d потомков. Один узел, являющийся исключением, может иметь от 1 до d-1 потомка;\r\n- Если h - глубина дерева, то для любого i = 1, ..., k-1 такое дерево имеет ровно d^i узлов глубины i;\r\n- Количество узлов глубины k в дереве глубины k может варьироваться от 1 до d^k;\r\n- Каждый узел имеет вес. Иначе говоря, каждому узлу дерева присвоен ключ такого типа данных, на котором определен порядок сравнения;\r\n- Ключ элемента, приписанного узлу i, не превосходит ключа любого из своих потомков.\r\n- \r\n####Бинарное дерево\r\n\r\n#####Бинарное поисковое дерево\r\nБинарное поисковое дерево - это двоичное дерево, обладающее следующими свойствами:\r\n* каждый узел имеет не больше двух потомков;\r\n* любое поддерево является бинарным поисковым деревом;\r\n* значение ключа любого узла левого поддерева меньше значения ключа корневого узла;\r\n* значение ключа любого узла правого поддерева больше значения ключа корневого узла.\r\n\r\n#####АВЛ-дерево\r\nАВЛ-дерево - сбалансированное по высоте бинарное поисковое дерево, обладающее следующим свойством:\r\n* для каждой вершины дерева высота её двух поддеревьев различается не больше чем на 1.\r\n\r\n####Таблицы\r\n\r\n#####Просматриваемые таблицы\r\nТаблица - динамическая структура данных, хранящая однотипные элементы. Записи хранятся в векторе памяти в порядке добавления (добавление производится в конец таблицы). При удалении записи просиходит перепаковка (сдвиг всех записей ниже текущей на одну позицию вверх).\r\n\r\n#####Упорядоченные таблицы\r\nУпорядоченная таблица - это просматриваемая таблица, данные в которой отсортированы по невозрастанию/неубыванию ключей. Причем при вставке и удалении происходят перепаковки.\r\n\r\n####Приоритетная очередь\r\nПриоритетная очередь — это динамическая структура данных, содержащая элементы, каждый из которых имеет определенный приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они распологаются в зависимости от своей позиции в очереди. \r\n\r\n####Разделенные множества\r\nРазледенные множества - абстрактный тип данных, предназначенный для представления коллекции k попарно непересекающихся можеств.\r\n\r\n###Описание алгоритмов\r\n\r\n####Пирамидальная сортировка\r\n\r\n1. Вектор значений переписывается в d-кучу.\r\n2. Просматривается минимальный элемент кучи и кладется в результирующий вектор.\r\n3. Минимальный элемент д-кучи меняется с последним.\r\n4. Декрементируется размер д-кучи.\r\n5. Погружение нулевого элемента.\r\n6. Если размер кучи положителен, переход к п.2, иначе алгоритм завершается.\r\n\r\nТаким образом вощвращаемый вектор значений будет отсортирован по неубыванию.\r\n\r\n####Алгоритм Дейкстры\r\n\r\n1. Задается взвешенный граф из n вершин.\r\n2. Задается стартовая вершина CUR.\r\n3. Создается вектор для отметки посещения вершины V (все элементы зануляются, V[CUR] = CUR).\r\n4. Создается результирующий вектор расстояний DIST (все элементы устремлены в бесконечность, DIST[CUR] = 0).\r\n5. Создается приоритетная очередь, в которую кладется расстояние от текущей вершины до неё же.\r\n6. Пока очередь не пуста:\r\n\t1. Вынимается минимальный элемент.\r\n\t2. Если метка вынутого элемента больше метки, хранящейся в массиве DIST, переход к следующему шагу.\r\n\t3. По всем ребрам от текущей вершины: Если результирующее расстояние от смежной вершины больше, чем результирующее расстояние до вынутой в пункте 6.1 вершины в сумме с меткой ребра, вынутогов пункте 6.3, выполняем:\r\n\t\t1. В вектор V по номеру смежной вершины кладется значение вершины, вынутой на этапе 6.1.\r\n\t\t2. В вектор DIST по номету смежной вершины пишется новое значение расстояния, равное сумме результирующего расстояния до вынутой в пункте 6.1 вершины и меткои ребра, вынутогов пункте 6.3.\r\n\t\t3. Обработанное ребро кладется в очередь.\r\n\r\nРезультатом работы алгоритма становится вектор расстояний до каждой вершины графа (DIST) и вектор обхода вершин графа для получения указанных значений (V).\r\n\r\n####Алгоритм Крускала\r\n\r\n1. Задается взвешенный неориентированный граф из n вершин.\r\n2. Создается приоритетная очередь из ребер графа (приоритет по метке ребра).\r\n3. Содрается коллекция из множества вершин.\r\n4. Вынимается ребро из приоритетной очереди.\r\n5. Если вынутые вершины находятся не в одной коллекции:\r\n\t1. Объединяются коллекции, содержащие данные вершины.\r\n\t2. Вынутое ребро добавляется в результирующий набор ребер.\r\n7. Если количество коллекций вершин больше количества компонент связности графа, переход к пункту 4, иначе алгоритм завершается.\r\n\r\nВ результате работы алгоритма имеется набор ребер, составляющих минимальное остовное дерево данного графа.\r\n\r\n###Программная реализация структур данных\r\n\r\n####Программная реализация d-кучи\r\n\r\nВ лабораторной работе d-куча представлена классом *D_HEAP*, содержащим нижеизложенные public-методы:\r\n- `D_HEAP(int, int)` - конструктор. Принимает на вход стартовый размер вектора памяти для хранения d-кучи и арность.\r\n- `D_HEAP(const D_HEAP<KeyType>&)` - конструктор копирования.\r\n- `~D_HEAP (void)` - деструктор.\r\n- `operator==(const D_HEAP<KeyType>&)const` - перегруженный оператор сравнения на равенство (требуется для проведения тестов).\r\n- `operator!=(const D_HEAP<KeyType>&)const` - перегруженный оператор сравнения на неравенство (требуется для проведения тестов).\r\n- `getSizeTree(void)const` - возвращает количество узлов, содержащихся в d-куче.\r\n- `getNodeKey(int)const` - возврацает ключ узла, номер которого передан в качестве параметра.\r\n- `getSizeReservedMem(void)const` - возвращает размер свободной памяти в выделенном ранее векторе памяти.\r\n- `getD(void)const` - возвращает арность кучи.\r\n- `swap(int, int)` - меняет местами узлы, индексы которых переданы в качестве параметров.\r\n- `siftDown(int)` - выполняет погружение узла с индексом, указанным в качестве аргумента.\r\n- `siftUp(int)` - выполняет всплытие узла с индексом, указанным в качестве аргумента.\r\n- `insert(const KeyType&, mem_rc flag = ALLOW_MEMORY_REALLOCATION_WCV, int size = 0)` - производит вставку узла, переданного первым аргументом в дерево. Вторым параметром указывается правило обработки ситуации, когда вставляется узел в полное дерево:\r\n\t- `ALLOW_MEMORY_REALLOCATION_WYV` - разрешить выделить дополнительную память при вставке узла в полное дерево. Размер добавляемой памяти указывается в качестве третьего параметра.\r\n\t- `ALLOW_MEMORY_REALLOCATION_WCV` - разрешить выделить дополнительную память при вставке узла в полное дерево, однако третий аргумент метода в этом случае игнорируется, выделение же памяти будет таковым, что появляется место минимум под один узел, максимум под d узлов. Текущее значение выделения памяти будет таковым, чтобы выполнялись указанные условия и одно дополнительное: новый размер вектора памяти делится на арность кучи.\r\n\t- `PROHIBIT_MEMORY_REALLOCATION` - запретить выделение дополнительной памяти при вставке узла в полное дерево.\r\n- `deleteMinElem(void)` - удаление узла с минимальным весом.\r\n- `deleteElem(int)` - удаление узла дерева по индексу хранения в векторе памяти.\r\n- `heapify(void)` - окучивание.\r\n- `getTree(void)const` - возвращает вектор значений, содержащихся в векторе памяти, что хранит исходное дерево (требуется для тестирования).\r\n- `operator<<(...)` - печать массива, хранящего значения узлов.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация бинарного поискового дерева\r\nУзел дерева представляется классом `NODE`, содержащим следующие поля:\r\n* `KeyType data_` - данные.\r\n* `NODE<KeyType>* left_` - указатель на левого потомка.\r\n* `NODE<KeyType>* right_` - указатель на правого потомка.\r\n* `NODE<KeyType>* parent_` - укаазатель на родителя.\r\n* `short balance_` - показатель перевеса правого или левого поддерева (используется в АВЛ-дереве).\r\n\r\nБинарное поисковое дерево представлено классом *BST*, содержащим нижеизложенные методы:\r\n* `getNodeForErasing(const KeyType&)` - вынимает из дерева узел, который требуется удалить.\r\n* `recursiveErase(NODE<KeyType>*&)` - удаляет дерево.\r\n* `copy(NODE<KeyType>*, NODE<KeyType>*)` - копирует дерево.\r\n* `BST(void)` - конструктор.\r\n* `BST(const BST<KeyType>& tree)` - конструктор копирования.\r\n* `~BST(void)` - деструктор.\r\n* `insert(const KeyType&)` - вставка нового элемента в дерево.\r\n* `erase(const KeyType&)` - удаление узла из дерева по заданному ключу.\r\n* `find(const KeyType&)const` - поиск узла дерева, содержащего указанный ключ.\r\n* `findMin(NODE<KeyType>* node = NULL)const` - поиск минимального элемента в дереве, корень которого передан в качестве параметра.\r\n* `findMax(NODE<KeyType>* node = NULL)const` - поиск максимального узла в дереве, корень которого передан в качестве параметра.\r\n* `findPrev(NODE<KeyType>*)const` - поиск узла, являющегося предыдущим по значению для текущего.\r\n* `findNext(NODE<KeyType>*)const` - поиск узла, являющегося следующим по значению для текущего.\r\n* `getSize(void)const` - получение количества узлов в дереве.\r\n* `recPostOrder(void)const` - обратный обход дерева.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация АВЛ-дерева\r\nАВЛ-дерево представлено классом *AVL_TREE*, наследуемым от класса *BST*, содержащим нижеизложенные методы:\r\n* `getDepth(NODE<KeyType>* node = NULL)const` - получает глубину дерева, корень которого передан в качестве параметра.\r\n* `doSingleLeftRotation(NODE<KeyType>*&)` - левый поворот.\r\n* `doSingleRightRotation(NODE<KeyType>*&)` - правый поворот.\r\n* `doDoubleLeftRotation(NODE<KeyType>*&)` - двойной левый поворот.\r\n* `doDoubleRightRotation(NODE<KeyType>*&)` - двойной правый поворот.\r\n* `updateLeftTree(NODE<KeyType>*&)` - преобразование левого поддерева (вызов правых поворотов).\r\n* `updateRightTree(NODE<KeyType>*&)` - преобразование правого поддерева (вызов левых поворотов).\r\n* `makeBalancing(NODE<KeyType>*&)` - балансировка дерева.\r\n* `doRecursiveInsertion(NODE<KeyType>*&, NODE<KeyType>*)` - вставка узла в дерево.\r\n* `getNodeForErasing(NODE<KeyType>*&, const KeyType&)` - вынимание из дерева узла для удаления.\r\n* `AVL_TREE(void)` - конструктор.\r\n* `AVL_TREE(const AVL_TREE<KeyType>& tree)` - сонструктор копирования.\r\n* `AVL_TREE(const BST<KeyType>&)` - конструктор преобразования типа.\r\n* `~AVL_TREE(void)` - деструктор.\r\n* `erase(const KeyType&)` - переопределенный метод вставки узла.\r\n* `insert(const KeyType&)` - переопределенный метод удаления узла.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация просматриваемых таблиц\r\nЗапись в таблице представлена классом `TAB_RECORD`, содержащим в качестве поля ключ с определенным отношением порядка.\r\nБаза для всех таблиц представлена классом *TABLE*, содержащим чисто виртуальные и виртуальные методы. Виртуальные методы с базовой реализацией:\r\n* `isEmpty(void)const` - проверка таблицы на пустоту.\r\n* `isFull(void)const` - проверка таблицы на полноту.\r\n* `getCount(void)const` - получение текущего количества записей.\r\n* `reset(void)` - установка индекса навигации в стартовую позицию.\r\n* `goNext(void)` - перевод индекса навигации на следующую позицию.\r\n* `isTabEnded(void)const` - проверка достижения индексом навигации конца таблицы.\r\n\r\nПросматриваемые таблицы представлены классом *SCAN_TABLE*, содержащим нижеизложенные методы:\r\n* `SCAN_TABLE(size_t size)` - конструктор (выделяет вектор памяди для хранения данных таблицы).\r\n* `SCAN_TABLE(const SCAN_TABLE<DataType>& table)` - конструктор копирования.\r\n* `~SCAN_TABLE(void)` - деструктор.\r\n* `find(const DataType&)` - поиск записи с суказанным ключом.\r\n* `insert(const TAB_RECORD<DataType>&)` - вставка новой записи.\r\n* `erase(const DataType&)` - удаление записи из даблицы.\r\n* `getCurrentRecord(void)const` - получение записи, закрепленной за индексом навигации.\r\n* `eraseCurrentRecord(void)` - удаление записи, закрепленной за индексом навигации.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация упорядоченных таблиц\r\nУпорядоченные таблицы наследуются от класса *SCAN_TABLE* и представлены классом *SORT_TABLE*, содержащим нижеизложенные методы:\r\n* `sort(void)` - сортировка данных (требуется для конструктора преобразования типа).\r\n* `SORT_TABLE(size_t size)` - конструктор.\r\n* `SORT_TABLE(const SORT_TABLE<DataType>& table)` - конструктор копирования.\r\n* `SORT_TABLE(const SCAN_TABL<DataType>E& table)` - конструктор преобразования типа.\r\n* `~SORT_TABLE(void)` - деструктор.\r\n* `find(const DataType&)` - переопределенный метод поиска записи с указанным ключом (используется бинарный поиск).\r\n* `insert(const TAB_RECORD<DataType>&)` - переопределенный метод вставки новой записи в таблицу.\r\n* `erase(const DataType&)` - переопределенный метод удаления записи из таблицы.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация приоритетной очереди\r\nПриоритетная очередь представлена базовым абстрактным классом *PRIORITY_QUEUE*, от которого наследуются классы *PRIORITY_QUEUE_ON_D_HEAP*, *PRIORITY_QUEUE_ON_AVL_TREE*, *PRIORITY_QUEUE_ON_SORT_TABLE*, содержащие идентичные, но переопределенный методы:\r\n* `PRIORITY_QUEUE_ON_*(void)` - конструктор (выделяет память под базовую структуру данных).\r\n* `PRIORITY_QUEUE_ON_*(const PRIORITY_QUEUE_ON_*<KeyType>&)` - конструктор копирования.\r\n* `~PRIORITY_QUEUE_ON_*(void)` - деструктор.\r\n* `getSize(void)const` - получение количества элементов в очереди.\r\n* `isEmpty(void)const` - проверка на пустоту.\r\n* `isFull(void)const` - проверка на полноту.\r\n* `pop(void)` - удаление элемента с наивысшим приоритетом.\r\n* `push(const KeyType&)` - вставка элемента.\r\n* `back(void)const` - простотр элемента с наивысшим приоритетом.\r\n\r\nКлассы реализованы шаблонными, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация разделенных множеств\r\nРазделенные множества представлены классом *DISJOINT_SET*, содержащим следующие методы:\r\n- `DISJOINT_SET<KeyType>(int)` - конструктор; принимает в качестве аргумента максимальное суммарное количество элементов множеств.\r\n- `DISJOINT_SET<KeyType>(const DISJOINT_SET<KeyType>&)` - конструктор копирования.\r\n- `~DISJOINT_SET<KeyType>(void)` - деструктор.\r\n- `createSet(int)` - создает одноэлементное множество с элементом, указанным в качестве аргумента.\r\n- `uniteSets(int, int)` - объединяет два множества (множества передаются номером главного элемента).\r\n- `findSet(int)` - возвращает главный элемент множества, если элемент принадлежит какому-либо множеству, иначе -1.\r\n- `getNumberOfSets(void)const` - возвращает текущее количество множеств (требуется для тестирования).\r\n- `getUniversalSet(void)const` - возвращает вектор, хранящий структуру множеств (требуется для тестирования).\r\n- `getSet(int)const` - возвращает вектор элементов, содержащихся в множестве, которое указано в качестве аргумента (множество задается главным элементом).\r\n- `operator<<(...)` - выводит вектор, содержащий структуру множеств.\r\n\r\nПредставленный набор методов достаточен для проведения тестирования корректности представления и работы класса, а также использования его в иных алгоритмах.\r\n\r\n###Представление графа\r\nРебро представляется классом-сущностью *EDGE*. Класс содержит три public-поля:\r\n * `first: size_t`.\r\n * `second: size_t`.\r\n * `distance: double`.\r\n Где first и second содержат связываемые вершины (в порядке неубывания), а distance - вес ребра.\r\n\r\nГраф представлен классом *GRAPH*, содержащим нижеизложенные методы:\r\n* `GRAPH(size_t)` - конструктор.\r\n* `GRAPH(const GRAPH&)` - конструктор копирования.\r\n* `~GRAPH(void)` - деструктор.\r\n* `setDistance(size_t, size_t, double)` - устанавливает ребро графа.\r\n* `getDistance(size_t, size_t)` - возвращает вес ребра графа (0, если ребра нет).\r\n* `getNumOfVertices(void)` - возвращает число вершин графа.\r\n* `eraseEdge(size_t, size_t)` - удалает ребро из графа, если оно присутствует.\r\n* `fillGraph(void)` - метод заполнения графа (вручную).\r\n* `createGraph(size_t, double, double)` - создание графа со случайными метками ребер.\r\n* `getNumOfComponents(void)const` - получение количества компонент связности графа.\r\n* `getAllEdges(void)` - возвращает множество всех ребер графа.\r\n* `getSetOfEdges(size_t)` - возвращает множество пар: смежная вершина и расстояние до неё.\r\n* `graphInfo(void)` - вывод информации о графе.\r\n\t* количество вершин;\r\n\t* количество ребер;\r\n\t* список ребер.\r\n\r\n##Заключение\r\nВ ходе лабораторной работы были реализованы структуры данных \"d-куча\", \"бинарное поисковое дерево\", \"АВЛ-сбалансированное дерево\", \"просматриваемая таблица\", \"упорядоченная таблицы\" \"приоритетная очередь\" и \"разделенные множества\" с использованием шаблонных классов. Также написано тестирующее приложение, которое покрывает все методы, используемые в указанных классах (Все тесты успешно пройдены). Написаны консольные приложения:\r\n* пирамидальная сортировка массива, заполняемого случайным образом;\r\n* алгоритм Дейкстры для поиска кратчайших путей от некоторой стартовой вершины связного неориентированного взвешенного графа без петель до всех прочих с использованием приоритетной очереди, основанной на d-куче;\r\n* алгоритм Крускала для построения минимального остовного дерева/леса неориентированного взвешенного графа без петель с использованием приоритетных очередей на базе d-кучи, упорядоченных таблиц и АВЛ-сбалансированных деревьев.\r\n\r\n##Литература\r\n1. Кормен Т., Лейзерсон Ч., Риверст Р., Штайн К. Алгоритмы. Построение и анализ. - М.: Издательский дом \"Вильямс\". - 2005. - 1290с.\r\n2. Алексеев В.Е., Таланов В.А. Графы. Модели вычислений. Структуры данных: Учебник. – Нижний Новгород: Изд-во ННГУ, 2005. 307 с.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}