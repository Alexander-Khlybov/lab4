{
  "name": "Lab4",
  "tagline": "",
  "body": "﻿# Реализация приоритетной очереди на основе различных структур данных и ее применение для построения остовного дерева графа с помощью алгоритма Крускала\r\n\r\n## Содержание\r\n\r\n* [Постановка задачи](#Постановка-задачи)\r\n* [Руководство пользователя](#Руководство-пользователя)\r\n\t* [Использование реализации алгоритма Дейкстры](#Использование-реализации-алгоритма-Дейкстры)\r\n\t* [Использование реализации алгоритма Крускала](#Использование-реализации-алгоритма-Крускала)\r\n* [Руководство программиста](#Руководство-программиста)\r\n\t* [Используемые технологии](#Используемые-технологии)\r\n\t* [Общая структура репозитория](#Общая-структура-репозитория)\r\n\t* [Описание структуры решения](#Описание-структуры-решения)\r\n\t* [Описание структур данных](#Описание-структур-данных)\r\n\t\t* [D-куча](#d-куча)\r\n\t\t* [Бинарное поисковое дерево](#Бинарное-поисковое-дерево)\r\n\t\t* [Таблицы](#Таблицы)\r\n\t\t\t* [Просматриваемые таблицы](#Просматриваемые-таблицы)\r\n\t\t\t* [Упорядоченные таблицы](#Упорядоченные-таблицы)\r\n\t\t* [Приоритетная очередь](#Приоритетная-очередь)\r\n\t\t* [Разделенные множества](#Разделенные-множества)\r\n\t* [Описание алгоритмов](#Описание-алгоритмов)\r\n\t\t* [Пирамидальная сортировка](#Пирамидальная-сортировка)\r\n\t\t* [Алгоритм Дейкстры](#Алгоритм-Дейкстры)\r\n\t\t* [Алгоритм Крускала](#Алгоритм-Крускала)\r\n\t* [Программная реализация структур данных](#Программная-реализация-структур-данных)\r\n\t\t* [Схема наследования классов](#Схема-наследования-классов)\r\n\t\t* [Программная реализация d-кучи](#Программная-реализация-d-кучи)\r\n\t\t* [Программая реализация бинарного поискового дерева](#Программая-реализация-бинарного-поискового-дерева)\r\n\t\t* [Программая реализация просматриваемых таблиц](#Программая-реализация-просматриваемых-таблиц)\r\n\t\t* [Программая реализация упорядоченных таблиц](#Программая-реализация-упорядоченных-таблиц)\r\n\t\t* [Программая реализация приоритетной очереди](#Программая-реализация-приоритетной-очереди)\r\n\t\t* [Программая реализация разделенных множеств](#Программая-реализация-разделенных-множеств)\r\n\t* [Представление графа](#Представление-графа)\r\n* [Заключение](#Заключение)\r\n* [Литература](#Литература)\r\n\r\n\r\n##Постановка задачи\r\n\r\n1. Разработать статические библиотеки, реализующие слудующие структуры данных:\r\n\t* d-куча;\r\n\t* бинарное поисковое дерево;\r\n\t* просматриваемая таблица;\r\n\t* упорядоченная таблица;\r\n\t* приоритетная очередь, основанная на d-куче;\r\n\t* приоритетная очередь, основанная на бинарном поисковом дереве;\r\n\t* приоритетная очередь, основанная на упорядоченной таблице;\r\n\t* разделенные множества.\r\n2. Написать тестирующую программу для каждой структуры данных с помощью Google C++ Testing Framework.\r\n3. Написать приложение для демонстрации работы d-кучи (пирамидальная сортировка).\r\n4. Написать приложение для демонстрации работы приоритетной очереди, основанной на d-куче (алгоритм Дейкстры):\r\n\t* входные данные - связный неориентированный взвешенный граф без петель со стартовой вершиной;\r\n\t* выходные данные - список расстояний до каждой вершины графа.\r\n5. Написать приложение для демонстрации работы приоритетной очереди и разделенных множеств (алгоритм Крускала):\r\n\t* входные данные - связный неориентированный взвешенный граф без петель;\r\n\t* выходные данные - граф, представляющий минимальное остовное дерево для исходного графа.\r\n\r\n##Руководство пользователя\r\n\r\n###Использование реализации алгоритма Дейкстры\r\n\r\n####Запуск приложения и ввод данных\r\n\r\nПрограмма предназначена для поиска кратчайших путей во взвешенном неориентированном графе от некоторой вершины, называемой текущей, до всех остальных вершин графа.\r\nДля запуска приложения нужно открыть исполняемый файл `sample_Dijkstra.exe`.\r\nПрограмма попросит ввести количество вершин графа и ребра с весом. Также будет запрошен номер вершины, являющейся стартовой. Результатом будет вывод вектора, содержащего номера вершин, что предшествуют вершинам, являющимся индексами вектора, для построения дерева, позволяющего восстановить обход и вывод списка расстояний от стартовой вершины до каждой из следующих вершин в порядке возрастания номера.\r\n\r\n####Пример:\r\n\r\nРассмотрим граф:\r\n\r\n![graph](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph.png)\r\n\r\nДля рассматриваемого графа алгоритм считает расстояния от вершины №1 до всех остальных вершин (ребра, через которые проходит кратчайший путь до вершины, помечены цветом этой вершины):\r\n\r\n![graph_Dijkstra](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph_Dijkstra.png)\r\n\r\n#####Шаг 1\r\nВвод количества вершин графа\r\n\r\n![Dijkstra1](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra1.png)\r\n\r\n#####Шаг 2\r\nВвод ребер и их весов\r\n\r\n![Dijkstra2](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra2.png)\r\n\r\n#####Шаг 3\r\nВыбор стартовой вершины\r\n\r\n![Dijkstra3](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra3.png)\r\n\r\n#####Шаг 4\r\nВывод результата и завершение работы программы\r\n\r\n![Dijkstra4](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Dijkstra4.png)\r\n\r\n###Использование реализации алгоритма Крускала\r\n\r\n####Запуск приложения и ввод данных\r\n\r\nПрограмма предназначена для построения минимального остовного дерева для взвешенного неориентированного графа. \r\nДля запуска приложения нужно открыть исполняемый файл `sample_Kruskal.exe`.\r\nПрограмма попросит ввести количество вершин графа и ребра с весом. Результатом работы программы будет вывод списка ребер, составляющих минимальное остовное дерево.\r\n\r\n####Пример\r\n\r\nРассмотрим граф:\r\n\r\n![graph](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph.png)\r\n\r\nДля рассматриваемого графа алгоритм строит дерево, выделенное зеленым цветом:\r\n\r\n![graph_Kruskal](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/graph_Kruskal.png)\r\n\r\n#####Шаг 1\r\nВвод количества вершин графа\r\n\r\n![Kruskal1](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal1.png)\r\n\r\n#####Шаг 2\r\nВвод ребер и их весов\r\n\r\n![Kruskal2](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal2.png)\r\n\r\n#####Шаг 3\r\nВыбор базы для приоритетной очереди\r\n\r\n![Kruskal3](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal3.png)\r\n\r\n#####Шаг 4\r\nВывод результата и завершение работы программы\r\n\r\n![Kruskal4](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/Kruskal4.png)\r\n\r\n##Руководство программиста\r\n\r\n###Используемые технологии\r\n\r\nВ ходе выполнения работы использованы следующие технологии:\r\n- Среда разработки Microsoft Visual Studio Community (2015).\r\n- Фреймворк для написания автоматических тестов Google Test.\r\n- Система контроля версий Git.\r\n\r\n###Общая структура репозитория\r\n\r\nРепозиторий содержит следующие директории и файлы:\r\n\r\n* [`gtest`](https://github.com/Alexander-Khlybov/lab4/tree/master/gtest) - библиотека GoogleTest.\r\n* [`src`](https://github.com/Alexander-Khlybov/lab4/tree/master/src) - директория для размещения файлов исходноо кода.\r\n* [`include`](https://github.com/Alexander-Khlybov/lab4/tree/master/include) - директория для размещения заголовочных файлов.\r\n* [`sample`](https://github.com/Alexander-Khlybov/lab4/tree/master/samples) - директория для размещения исходных кодов приложений.\r\n* [`test`](https://github.com/Alexander-Khlybov/lab4/tree/master/test) - директория для размещения тестов.\r\n* [`sln`](https://github.com/Alexander-Khlybov/lab4/tree/master/sln/) - директория с файлими решений (на данный момент Visual Studio 2015).\r\n* [`Rept`](https://github.com/Alexander-Khlybov/lab4/tree/master/Rept) - директория с материалами для отчета;\r\n* Служебные файлы:\r\n  * `.gitignore` - перечень расширений файлов, игнорируемых Git при добавлении файлов в репозиторий.\r\n\r\n###Описание структуры решения\r\n\r\nРешение состоит из 12 проектов:\r\n\r\n* `gtest` - фреймворк Google Test;\r\n* `d-heap_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `D_HEAP`.\r\n* `disjoint-set_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `DISJOINT_SET`.\r\n* `binary_search_tree_lib` - статическая библиотка, содержащая объявление и реализацию класса `BST`.\r\n* `tables_lib` - статическая библиотека, содержащая объявление и реализацию шаблонных классов `TABLE`, `SCAN_TABLE`, `SORT_TABLE`.\r\n* `graph_lib` - статическая библиотека, содержащая объявление и реализацию класса `GRAPH`.\r\n* `priority_queue_lib` - статическая библиотека, содержащая объявление и реализацию шаблонных классов приоритетных очередей, основанных на разных структурах данных.\r\n* `algorithms` - статическая библиотека, содержащая объявление и реализацию алгоритмов для примеров.\r\n* `sampleDijkstra` - консольное приложение для демонстрации работы алгоритма Дейкстры.\r\n* `sample_Kruskal` - консольное приложение для демонстрации работы алгоритма Крускала.\r\n* `sample_d-heap` - консольное приложение для демонстрации работы пирамидальной сортировки.\r\n* `test` - консольно приложение для проверки правильности реализации классов `D_HEAP`, `PRIORITY_QUEUE`, `DISJOINT_SET`.\r\n\r\n###Описание структур данных\r\n\r\n####D-куча\r\nD-куча - завершенное d-арное дерево, содержащее набор однотипных элементов, со следующими свойствами:\r\n- каждый узел, не являющийся листом, за исключением, быть может, одного имеет ровно d потомков. Один узел, являющийся исключением, может иметь от 1 до d-1 потомка;\r\n- если h - глубина дерева, то для любого i = 1, ..., k-1 такое дерево имеет ровно d^i узлов глубины i;\r\n- количество узлов глубины k в дереве глубины k может варьироваться от 1 до d^k;\r\n- каждый узел имеет вес. Иначе говоря, каждому узлу дерева присвоен ключ такого типа данных, на котором определен порядок сравнения;\r\n- ключ элемента, приписанного узлу i, не превосходит ключа любого из своих потомков.\r\n\r\n#####Основные операции:\r\n* Всплытие:\r\n```\r\nВСПЛЫТИЕ(i){\r\n\tp = (i - 1) / d;\r\n\twhile (i != 0 && key[p] > key[i]){ // Здесь и далее `key[]` - массив, хранящий d-кучу\r\n\t\tТРАНСПОНИРОВАНИЕ(i, p);\r\n\t\ti = p;\r\n\t\tp = (i - 1) / d;\r\n\t}\r\n}\r\n```\r\n* Погружение:\r\n```\r\nПОГРУЖЕНИЕ(i){\r\n\tс = minchild(i); // Здесь и далее minchild возвращает индекс, по которому хранится ребенок минимального веса для данного родителя\r\n\twhile (i != 0 && key[c] < key[i]){\r\n\t\tТРАНСПОНИРОВАНИЕ(i, c);\r\n\t\ti = c;\r\n\t\tc = minchild(c);\r\n\t}\r\n}\r\n```\r\n* Транспонирование:\r\n```\r\nТРАНСПОНИРОВАНИЕ(i, j){\r\n\ttmp = key[i];\r\n\tkey[i] = key[j];\r\n\tkey[j] = tmp;\r\n}\r\n```\r\n* Вставка:\r\n```\r\nВСТАВКА(x){\r\n\tkey[size] = x;\r\n\tВСПЛЫТИЕ(size);\r\n\tsize += 1;\r\n}\r\n```\r\n* Удаление:\r\n```\r\nУДАЛЕНИЕ(i){\r\n\tkey[i] = key[size - 1];\r\n\tsize -= 1;\r\n\tПОГРУЖЕНИЕ(i);\r\n}\r\n```\r\n* Окучивание:\r\n```\r\nОКУЧИВАНИЕ(){\r\n\tfor(size_t i = size - 1; i >= 0; i--)\r\n\tПОГРУЖЕНИЕ(i);\r\n}\r\n```\r\n* Доступ к элементу:\r\n```\r\nПОЛУЧИТЬ(i){\r\n\treturn key[i];\r\n}\r\n```\r\n\r\n####Бинарное поисковое дерево\r\nБинарное поисковое дерево - это двоичное дерево, обладающее следующими свойствами:\r\n* каждый узел имеет не больше двух потомков;\r\n* любое поддерево является бинарным поисковым деревом;\r\n* значение ключа любого узла левого поддерева меньше значения ключа корневого узла;\r\n* значение ключа любого узла правого поддерева больше значения ключа корневого узла.\r\n\r\n#####Основные операции:\r\n* Поиск:\r\n```\r\nПОИСК(key){\r\n\tnode = root; // Здесь и далее `root` - корневой узел дерева\r\n\twhile(node != 0 && node->key != key){\r\n\t\tif (node->key > key) node = node->left;\r\n\t\telse node = node->right;\r\n\t}\r\n\treturn node;\r\n}\r\n```\r\n* Поиск минимума:\r\n```\r\nМИНИМУМ(){\r\n\tnode = root;\r\n\twhile(node->left != 0)\r\n\t\tnode = node->left;\r\n}\r\n```\r\n* Поиск максимума:\r\n```\r\nМАКСИМУМ(){\r\n\tnode = root;\r\n\twhile(node->right != 0)\r\n\t\tnode = node->right;\r\n}\r\n```\r\n* Поиск предыдущего:\r\n```\r\nНАЙТИ_ПРЕДЫДУЩИЙ(node){\r\n\tif (node->left != 0) return МАКСИМУМ(node->left);\r\n\ty = x->parent;\r\n\twhile(y != 0 && x == y->left){\r\n\t\tx = y;\r\n\t\ty = y->parent;\r\n\t}\r\n\treturn y;\r\n}\r\n```\r\n* Поиск следующего:\r\n```\r\nНАЙТИ_СЛЕДУЮЩИЙ(node){\r\n\tif (node->right != 0) return МИНИМУМ(node->right);\r\n\ty = x->parent;\r\n\twhile(y != 0 && x == y->right){\r\n\t\tx = y;\r\n\t\ty = y->parent;\r\n\t}\r\n\treturn y;\r\n}\r\n```\r\n* Вставка:\r\n```\r\nВСТАВКА(node){\r\n\ty = 0;\r\n\tx = root;\r\n\twhile(x != 0){\r\n\t\ty = x;\r\n\t\tif (node->key < x->key) x = x->left;\r\n\t\telse x = x->right;\r\n\t}\r\n\tnode->parent = y;\r\n\tif (y == 0) root = node;\r\n\telse if (node->key < y->key) y->left = node;\r\n\telse y->right = node;\r\n}\r\n```\r\n* Удаление:\r\n```\r\nУДАЛЕНИЕ(key){\r\n\tnode = МИНИМУМ();\r\n\tif (node->parent == 0) {\r\n\t\tif (node->right_ == 0) {\r\n\t\t\troot = 0;\r\n\t\t\tdelete node;\r\n\t\t}\r\n\t\troot = node->right;\r\n\t\troot->parent = 0;\r\n\t\tnode->right = 0;\r\n\t\tdelete node;\r\n\t}\r\n\tnode->parent->left = node->right;\r\n\tnode->right = node->parent = NULL;\r\n\tdelete node;\r\n}\r\n```\r\n\r\n####Таблицы\r\n\r\n#####Просматриваемые таблицы\r\nТаблица - динамическая структура данных, хранящая однотипные элементы. Записи хранятся в векторе памяти в порядке добавления (добавление производится в конец таблицы). При удалении записи просиходит перепаковка (сдвиг всех записей ниже текущей на одну позицию вверх).\r\n\r\nОсновные операции:\r\n* Проверка на пустоту:\r\n```\r\nПУСТОТА(){\r\n\treturn ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ == 0;\r\n}\r\n```\r\n* Проверка на полноту:\r\n```\r\nПОЛНОТА(){\r\n\treturn ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ == РАЗМЕР_ТАБЛИЦЫ;\r\n}\r\n```\r\n* Вставка:\r\n```\r\nВСТАВИТЬ(record){\r\n\tif (!ПОЛНОТА()){\r\n\t\trecs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ] = record; // Здесь и далее `recs` - вектор, хранящий записи в таблице.\r\n\t\tТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ += 1;\r\n\t}\r\n}\r\n```\r\n* Удаление:\r\n```\r\nУДАЛЕНИЕ(key){\r\n\tif (!ПУСТОТА()){\r\n\t\trecord = recs[0];\r\n\t\ttmp = 0;\r\n\t\twhile(КЛЮЧ(recs[tmp]) != key && tmp <= ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ)\r\n\t\t\ttmp += 1;\r\n\t\tif (tmp > ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ) return;\r\n\t\trecs[tmp] = recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ - 1];\r\n\t\trecs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ - 1] = 0;\r\n\t\tТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ -= 1;\r\n\t}\r\n}\r\n```\r\n* Поиск:\r\n```\r\nНАЙТИ(key){\r\n\tif (ПУСТОТА()) return;\r\n\ttmp = 0;\r\n\twhile(КЛЮЧ(recs[tmp]) != key && tmp <= ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ)\r\n\t\ttmp += 1;\r\n\tif (tmp > ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ) return 0;\r\n\treturn recs[tmp];\r\n}\r\n```\r\n* Доступ:\r\n```\r\n\tПОЛУЧИТЬ(i){\r\n\t\treturn recs[i];\r\n\t}\r\n```\r\n\r\n#####Упорядоченные таблицы\r\nУпорядоченная таблица - это просматриваемая таблица, данные в которой отсортированы по невозрастанию/неубыванию ключей. Причем при вставке и удалении происходят перепаковки.\r\n\r\nОсновные операции:\r\n* Проверка напустоту (см. просматриваемые таблицы).\r\n* Проверка на полноту (см. просматриваемые таблицы).\r\n* Вставка:\r\n```\r\nВСТАВИТЬ(record){\r\n\tif (ПОЛНОТА()) return;\r\n\t\r\n\tНАЙТИ(КЛЮЧ(record), addr);\r\n\tfor (int i = ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; i >= addr && i > 0; i--)\r\n\t\trecs[i] = recs[i - 1];\r\n\tТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ += 1;\r\n\trecs[addr] = record;\r\n}\r\n```\r\n* Удаление:\r\n```\r\nУДАЛИТЬ(key){\r\n\tif (ПУСТОТА()) return;\r\n\taddr = 0;\r\n\tif (НАЙТИ(key, addr) == 0) return;\r\n\tdelete recs[addr];\r\n\tfor (size_t i = addr; i < ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ - 1; i++) {\r\n\t\trecs[i] = recs[i + 1];\r\n\t}\r\n\tТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ -=1;\r\n}\r\n```\r\n* Поиск:\r\n```\r\nНАЙТИ(key, & addr){\r\n\tleft = 0;\r\n\tright = ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ - 1;\r\n\tmid;\r\n\twhile (left <= right){\r\n\t\tmid = left + (right - left) / 2;\r\n\t\tif (key < КЛЮЧ(recs[mid])) {\r\n\t\t\tright = mid - 1;\r\n\t\t\taddr = left;\r\n\t\t}else if (key > КЛЮЧ(recs[mid])) {\r\n\t\t\tleft = mid + 1;\r\n\t\t\taddr = left;\r\n\t\t}\r\n\t\telse{\r\n\t\t\taddr = mid;\r\n\t\t\treturn recs[mid];\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n\r\n####Приоритетная очередь\r\nПриоритетная очередь — это динамическая структура данных, содержащая элементы, каждый из которых имеет определенный приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. \r\n\r\nОсновные операции:\r\n* Вставка элемента: `ВСТАВИТЬ(x)`.\r\n* Удаление старшего элемента: `УДАЛИТЬ()`.\r\n* Получение старшего элемента: `ПОЛУЧИТЬ()`.\r\n* Проверка на пустоту: `ПУСТОТА()`.\r\n* Проверка на полноту: `ПОЛНОТА()`.\r\n\r\n#####Реализация операций на разных структурах данных\r\n######D-куча\r\n\r\n* Вставка элемента:\r\n\r\n```\r\n\tВСТАВИТЬ(x);\r\n```\r\n\r\n* Удаление старшего элемента:\r\n\r\n```\r\n\tУДАЛИТЬ(0);\r\n```\r\n\r\n* Получение старшего элемента:\r\n\r\n```\r\n\treturn ПОЛУЧИТЬ(0);\r\n```\r\n\r\n* Проверка на пустоту:\r\n\r\n```\r\n\treturn КОЛИЧЕСТВО_ЭЛЕМЕНТОВ == 0;\r\n```\r\n\r\n* Проверка на полноту:\r\n```\r\n\treturn КОЛИЧЕСТВО_ЭЛЕМЕНТОВ == МАКСИМАЛЬНЫЙРАЗМЕР;\r\n```\r\n\r\n######Бинарное поисковое дерево\r\n\t \r\n* Вставка элемента:\r\n\r\n```\r\n\tВСТАВИТЬ(x);\r\n```\r\n\t \r\n* Удаление старшего элемента:\r\n\r\n```\r\n\tУДАЛИТЬ(КЛЮЧ(МИНИМУМ()));\r\n```\r\n\t \r\n* Получение старшего элемента:\r\n\r\n```\r\n\treturn КЛЮЧ(МИНИМУМ());\r\n```\r\n\t \r\n* Проверка на пустоту:\r\n\r\n```\r\n\treturn КОЛИЧЕСТВО_УЗЛОВ == 0;\r\n```\r\n\t \r\n* Проверка на полноту:\r\n\r\n```\r\n\treturn КОЛИЧЕСТВО_ЭЛЕМЕНТОВ == МАКСИМАЛЬНЫЙРАЗМЕР;\r\n```\r\n######Упорядоченные таблицы\r\n\t \r\n* Вставка элемента:\r\n\r\n```\r\n\tВСТАВИТЬ(x);\r\n```\r\n\t \r\n* Удаление старшего элемента:\r\n\r\n```\r\n\tУДАЛИТЬ(КЛЮЧ(ПОЛУЧИТЬ(0)));\r\n```\r\n\t \r\n* Получение старшего элемента:\r\n\r\n```\r\n\treturn КЛЮЧ(ПОЛУЧИТЬ(0));\r\n```\r\n\t \r\n* Проверка на пустоту:\r\n\r\n```\r\n\treturn ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ == 0;\r\n```\r\n\t \r\n* Проверка на полноту:\r\n\r\n```\r\n\treturn ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ == РАЗМЕР_ТАБЛИЦЫ;\r\n```\r\n\r\n####Разделенные множества\r\nРазледенные множества - абстрактный тип данных, предназначенный для представления коллекции k попарно непересекающихся можеств.\r\n\r\nОсновные операции:\r\n* Создать:\r\n```\r\nСОЗДАТЬ(x){\r\n    if (U[root] != -1) return; // Здесь и далее `U[]` - массив для хранения универса\r\n    U[root] = root;\r\n    ТЕКУЩЕЕ_КОЛИЧЕСТВО_МНОЖЕСТВ += 1;\r\n}\r\n```\r\n* Объединить:\r\n```\r\nОБЪЕДИНИТЬ(x, y){\r\n\tif (U[x] == -1 || U[y] == -1) return;\r\n\tU[MAX(x, y)] = MIN(x, y);\r\n\tТЕКУЩЕЕ_КОЛИЧЕСТВО_МНОЖЕСТВ -= 1;\r\n}\r\n```\r\n* Найти (позволяет определить имя корня множества):\r\n```\r\nНАЙТИ(x){\r\n\tif (U[x] == -1) return -1;\r\n\t\r\n\twhile(U[x] != x) x = U[x];\r\n\treturn x;\r\n}\r\n```\r\n\r\n###Описание алгоритмов\r\n\r\n####Пирамидальная сортировка\r\n\r\n#####Вход\r\n\r\nВектор значений.\r\n\r\n#####Выход\r\n\r\nВектор, содержащий в себе значения исходного, но последние отсортированы по неубыванию.\r\n\r\n#####Алгоритм\r\n\r\n1. Вектор значений переписывается в d-кучу.\r\n2. Просматривается минимальный элемент кучи и кладется в результирующий вектор.\r\n3. Минимальный элемент д-кучи меняется с последним.\r\n4. Декрементируется размер д-кучи.\r\n5. Погружение нулевого элемента.\r\n6. Если размер кучи положителен, переход к п.2, иначе алгоритм завершается.\r\n\r\nТаким образом, вощвращаемый вектор значений будет отсортирован по неубыванию.\r\n\r\n####Алгоритм Дейкстры\r\n\r\n#####Вход\r\n\r\nЗадается взвешенный (каждому ребру присвоено значение веса) связный (из любой вершины можно добраться до всех остальных вершин) граф. Задается стартовая вершина.\r\n\r\n#####Выход\r\n\r\nПри окончании работы алгоритма выходом является пара массивов, содержащих:\r\n* список предшествующих вершин для текущих, являющихся индексами, для построения дерева обхода;\r\n* список расстояний от стартовой вершины до всех остальных.\r\n\r\n#####Алгоритм\r\n\r\n1. Задается взвешенный граф из n вершин.\r\n2. Задается стартовая вершина CUR.\r\n3. Создается вектор для отметки посещения вершины V (все элементы зануляются, V[CUR] = CUR).\r\n4. Создается результирующий вектор расстояний DIST (все элементы устремлены в бесконечность, DIST[CUR] = 0).\r\n5. Создается приоритетная очередь, в которую кладется расстояние от текущей вершины до неё же.\r\n6. Пока очередь не пуста:\r\n\t1. Вынимается минимальный элемент.\r\n\t2. Если метка вынутого элемента больше метки, хранящейся в массиве DIST, переход к следующему шагу.\r\n\t3. По всем ребрам от текущей вершины: Если результирующее расстояние от смежной вершины больше, чем результирующее расстояние до вынутой в пункте 6.1 вершины в сумме с меткой ребра, вынутогов пункте 6.3, выполняем:\r\n\t\t1. В вектор V по номеру смежной вершины кладется значение вершины, вынутой на этапе 6.1.\r\n\t\t2. В вектор DIST по номету смежной вершины пишется новое значение расстояния, равное сумме результирующего расстояния до вынутой в пункте 6.1 вершины и меткои ребра, вынутогов пункте 6.3.\r\n\t\t3. Обработанное ребро кладется в очередь.\r\n\r\nРезультатом работы алгоритма становится вектор расстояний до каждой вершины графа (DIST) и вектор обхода вершин графа для получения указанных значений (V).\r\n\r\n####Алгоритм Крускала\r\n\r\n#####Вход\r\n\r\nЗадается взвешенный (каждому ребру присвоено значение веса) граф.\r\n\r\n#####Выход\r\n\r\nРезультатом работы алгоритма является вывод графа:\r\n* дерево, если исходный граф был связен;\r\n* лес, если исходный граф не был связен. Количество деревьев равно количеству компонент связности исходного графа.\r\n\r\n#####Алгоритм\r\n\r\n1. Задается взвешенный неориентированный граф из n вершин.\r\n2. Создается приоритетная очередь из ребер графа (приоритет по метке ребра).\r\n3. Содрается коллекция из множества вершин.\r\n4. Вынимается ребро из приоритетной очереди.\r\n5. Если вынутые вершины находятся не в одной коллекции:\r\n\t1. Объединяются коллекции, содержащие данные вершины.\r\n\t2. Вынутое ребро добавляется в результирующий набор ребер.\r\n7. Если количество коллекций вершин больше количества компонент связности графа, переход к пункту 4, иначе алгоритм завершается.\r\n\r\nВ результате работы алгоритма имеется набор ребер, составляющих минимальное остовное дерево данного графа.\r\n\r\n###Программная реализация структур данных\r\n\r\n####Схема наследования классов\r\n\r\n![classes](https://raw.githubusercontent.com/Alexander-Khlybov/lab4/master/Rept/classes.png)\r\n\r\n####Программная реализация d-кучи\r\n\r\nУзел d-кучи представляется ячейкой массива `tree_` (номер узла ассоциируется с номером ячейки массива).\r\n\r\nВ лабораторной работе d-куча представлена классом `D_HEAP`, содержащим нижеизложенные открытые методы:\r\n- `D_HEAP(int, int)` - конструктор. Принимает на вход стартовый размер вектора памяти для хранения d-кучи и арность.\r\n- `D_HEAP(const D_HEAP<KeyType>&)` - конструктор копирования.\r\n- `~D_HEAP (void)` - деструктор.\r\n- `operator==(const D_HEAP<KeyType>&)const` - перегруженный оператор сравнения на равенство (требуется для проведения тестов).\r\n- `operator!=(const D_HEAP<KeyType>&)const` - перегруженный оператор сравнения на неравенство (требуется для проведения тестов).\r\n- `getSizeTree(void)const` - возвращает количество узлов, содержащихся в d-куче.\r\n- `getNodeKey(int)const` - возврацает ключ узла, номер которого передан в качестве параметра.\r\n- `getSizeReservedMem(void)const` - возвращает размер свободной памяти в выделенном ранее векторе памяти.\r\n- `getD(void)const` - возвращает арность кучи.\r\n- `swap(int, int)` - меняет местами узлы, индексы которых переданы в качестве параметров.\r\n- `siftDown(int)` - выполняет погружение узла с индексом, указанным в качестве аргумента.\r\n- `siftUp(int)` - выполняет всплытие узла с индексом, указанным в качестве аргумента.\r\n- `insert(const KeyType&, mem_rc flag = ALLOW_MEMORY_REALLOCATION_WCV, int size = 0)` - производит вставку узла, переданного первым аргументом в дерево. Вторым параметром указывается правило обработки ситуации, когда вставляется узел в полное дерево:\r\n\t- `ALLOW_MEMORY_REALLOCATION_WYV` - разрешить выделить дополнительную память при вставке узла в полное дерево. Размер добавляемой памяти указывается в качестве третьего параметра.\r\n\t- `ALLOW_MEMORY_REALLOCATION_WCV` - разрешить выделить дополнительную память при вставке узла в полное дерево, однако третий аргумент метода в этом случае игнорируется, выделение же памяти будет таковым, что появляется место минимум под один узел, максимум под d узлов. Текущее значение выделения памяти будет таковым, чтобы выполнялись указанные условия и одно дополнительное: новый размер вектора памяти делится на арность кучи.\r\n\t- `PROHIBIT_MEMORY_REALLOCATION` - запретить выделение дополнительной памяти при вставке узла в полное дерево.\r\n- `deleteMinElem(void)` - удаление узла с минимальным весом.\r\n- `deleteElem(int)` - удаление узла дерева по индексу хранения в векторе памяти.\r\n- `heapify(void)` - окучивание.\r\n- `getTree(void)const` - возвращает вектор значений, содержащихся в векторе памяти, что хранит исходное дерево (требуется для тестирования).\r\n- `operator<<(...)` - печать массива, хранящего значения узлов.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация бинарного поискового дерева\r\nУзел дерева представляется классом `NODE`, содержащим следующие поля:\r\n* `KeyType data_` - данные.\r\n* `NODE<KeyType>* left_` - указатель на левого потомка.\r\n* `NODE<KeyType>* right_` - указатель на правого потомка.\r\n* `NODE<KeyType>* parent_` - укаазатель на родителя.\r\n* `short balance_` - показатель перевеса правого или левого поддерева (используется в АВЛ-дереве).\r\n\r\nБинарное поисковое дерево представлено классом `BST`, содержащим нижеизложенные методы:\r\n* `getNodeForErasing(const KeyType&)` - вынимает из дерева узел, который требуется удалить.\r\n* `recursiveErase(NODE<KeyType>*&)` - удаляет дерево.\r\n* `copy(NODE<KeyType>*, NODE<KeyType>*)` - копирует дерево.\r\n* `BST(void)` - конструктор.\r\n* `BST(const BST<KeyType>& tree)` - конструктор копирования.\r\n* `~BST(void)` - деструктор.\r\n* `insert(const KeyType&)` - вставка нового элемента в дерево.\r\n* `erase(const KeyType&)` - удаление узла из дерева по заданному ключу.\r\n* `find(const KeyType&)const` - поиск узла дерева, содержащего указанный ключ.\r\n* `findMin(NODE<KeyType>* node = NULL)const` - поиск минимального элемента в дереве, корень которого передан в качестве параметра.\r\n* `findMax(NODE<KeyType>* node = NULL)const` - поиск максимального узла в дереве, корень которого передан в качестве параметра.\r\n* `findPrev(NODE<KeyType>*)const` - поиск узла, являющегося предыдущим по значению для текущего.\r\n* `findNext(NODE<KeyType>*)const` - поиск узла, являющегося следующим по значению для текущего.\r\n* `getSize(void)const` - получение количества узлов в дереве.\r\n* `recPostOrder(void)const` - обратный обход дерева.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация просматриваемых таблиц\r\nЗапись в таблице представлена классом `TAB_RECORD`, содержащим в качестве поля ключ с определенным отношением порядка.\r\nБаза для всех таблиц представлена классом `TABLE`, содержащим чисто виртуальные и виртуальные методы. Виртуальные методы с базовой реализацией:\r\n* `isEmpty(void)const` - проверка таблицы на пустоту.\r\n* `isFull(void)const` - проверка таблицы на полноту.\r\n* `getCount(void)const` - получение текущего количества записей.\r\n* `reset(void)` - установка индекса навигации в стартовую позицию.\r\n* `goNext(void)` - перевод индекса навигации на следующую позицию.\r\n* `isTabEnded(void)const` - проверка достижения индексом навигации конца таблицы.\r\n\r\nПросматриваемые таблицы представлены классом `SCAN_TABLE`, содержащим нижеизложенные методы:\r\n* `SCAN_TABLE(size_t size)` - конструктор (выделяет вектор памяди для хранения данных таблицы).\r\n* `SCAN_TABLE(const SCAN_TABLE<DataType>& table)` - конструктор копирования.\r\n* `~SCAN_TABLE(void)` - деструктор.\r\n* `find(const DataType&)` - поиск записи с суказанным ключом.\r\n* `insert(const TAB_RECORD<DataType>&)` - вставка новой записи.\r\n* `erase(const DataType&)` - удаление записи из даблицы.\r\n* `getCurrentRecord(void)const` - получение записи, закрепленной за индексом навигации.\r\n* `eraseCurrentRecord(void)` - удаление записи, закрепленной за индексом навигации.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация упорядоченных таблиц\r\nУпорядоченные таблицы наследуются от класса `SCAN_TABLE` и представлены классом `SORT_TABLE`, содержащим нижеизложенные методы:\r\n* `sort(void)` - сортировка данных (требуется для конструктора преобразования типа).\r\n* `SORT_TABLE(size_t size)` - конструктор.\r\n* `SORT_TABLE(const SORT_TABLE<DataType>& table)` - конструктор копирования.\r\n* `SORT_TABLE(const SCAN_TABL<DataType>E& table)` - конструктор преобразования типа.\r\n* `~SORT_TABLE(void)` - деструктор.\r\n* `find(const DataType&)` - переопределенный метод поиска записи с указанным ключом (используется бинарный поиск).\r\n* `insert(const TAB_RECORD<DataType>&)` - переопределенный метод вставки новой записи в таблицу.\r\n* `erase(const DataType&)` - переопределенный метод удаления записи из таблицы.\r\n\r\nКласс реализован шаблонным, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация приоритетной очереди\r\nПриоритетная очередь представлена базовым абстрактным классом `PRIORITY_QUEUE`, от которого наследуются классы `PRIORITY_QUEUE_ON_D_HEAP` (агрегирует в себе d-кучу), `PRIORITY_QUEUE_ON_BINARY_SEARCH_TREE` (агрегирует в себе бинарное поисковое дерево), `PRIORITY_QUEUE_ON_SORT_TABLE` (агрегирует в себе упорядоченную таблицу), содержащие идентичные, но переопределенный методы:\r\n* `PRIORITY_QUEUE_ON_*(void)` - конструктор (выделяет память под базовую структуру данных).\r\n* `PRIORITY_QUEUE_ON_*(const PRIORITY_QUEUE_ON_*<KeyType>&)` - конструктор копирования.\r\n* `~PRIORITY_QUEUE_ON_*(void)` - деструктор.\r\n* `getSize(void)const` - получение количества элементов в очереди.\r\n* `isEmpty(void)const` - проверка на пустоту.\r\n* `isFull(void)const` - проверка на полноту.\r\n* `pop(void)` - удаление элемента с наивысшим приоритетом.\r\n* `push(const KeyType&)` - вставка элемента.\r\n* `back(void)const` - простотр элемента с наивысшим приоритетом.\r\n\r\nКлассы реализованы шаблонными, что позволяет хранить любого рода данные, для которых определен порядок сравнения.\r\n\r\n####Программая реализация разделенных множеств\r\nРазделенные множества представлены классом `DISJOINT_SET`. \r\n\r\nУзлы деревьев хранятся в массиве `U_`, который является некоторым универсальным множеством. Принцип формирования множеств описан в разделе [описание структур данных](#описание-структур-данных).\r\n\r\nКласс `DISJOINT_SET` содержит следующие методы:\r\n- `DISJOINT_SET<KeyType>(int)` - конструктор; принимает в качестве аргумента максимальное суммарное количество элементов множеств.\r\n- `DISJOINT_SET<KeyType>(const DISJOINT_SET<KeyType>&)` - конструктор копирования.\r\n- `~DISJOINT_SET<KeyType>(void)` - деструктор.\r\n- `createSet(int)` - создает одноэлементное множество с элементом, указанным в качестве аргумента.\r\n- `uniteSets(int, int)` - объединяет два множества (множества передаются номером главного элемента).\r\n- `findSet(int)` - возвращает главный элемент множества, если элемент принадлежит какому-либо множеству, иначе -1.\r\n- `getNumberOfSets(void)const` - возвращает текущее количество множеств (требуется для тестирования).\r\n- `getUniversalSet(void)const` - возвращает вектор, хранящий структуру множеств (требуется для тестирования).\r\n- `getSet(int)const` - возвращает вектор элементов, содержащихся в множестве, которое указано в качестве аргумента (множество задается главным элементом).\r\n- `operator<<(...)` - выводит вектор, содержащий структуру множеств.\r\n\r\nПредставленный набор методов достаточен для проведения тестирования корректности представления и работы класса, а также использования его в иных алгоритмах.\r\n\r\n###Представление графа\r\nРебро представляется классом-сущностью `EDGE`. Класс содержит три открытых поля:\r\n * `first: size_t`.\r\n * `second: size_t`.\r\n * `distance: double`.\r\nГде `first` и `second` содержат связываемые вершины (в порядке неубывания), а `distance` - вес ребра.\r\n\r\nГраф представляется множеством ребер (`multiset<EDGE>`).\r\n\r\nГраф представлен классом `GRAPH`, содержащим нижеизложенные методы:\r\n* `GRAPH(size_t)` - конструктор.\r\n* `GRAPH(const GRAPH&)` - конструктор копирования.\r\n* `~GRAPH(void)` - деструктор.\r\n* `setDistance(size_t, size_t, double)` - устанавливает ребро графа.\r\n* `getDistance(size_t, size_t)` - возвращает вес ребра графа (0, если ребра нет).\r\n* `getNumOfVertices(void)` - возвращает число вершин графа.\r\n* `eraseEdge(size_t, size_t)` - удалает ребро из графа, если оно присутствует.\r\n* `fillGraph(void)` - метод заполнения графа (вручную).\r\n* `createGraph(size_t, double, double)` - создание графа со случайными метками ребер.\r\n* `getNumOfComponents(void)const` - получение количества компонент связности графа.\r\n* `getAllEdges(void)` - возвращает множество всех ребер графа.\r\n* `getSetOfEdges(size_t)` - возвращает множество пар: смежная вершина и расстояние до неё.\r\n* `graphInfo(void)` - вывод информации о графе.\r\n\t* количество вершин;\r\n\t* количество ребер;\r\n\t* список ребер.\r\n\r\n##Заключение\r\nВ ходе лабораторной работы были реализованы структуры данных \"d-куча\", \"бинарное поисковое дерево\", \"просматриваемая таблица\", \"упорядоченная таблица\", \"приоритетная очередь\" и \"разделенные множества\" с использованием шаблонных классов. Также написано тестирующее приложение, которое покрывает все методы, используемые в указанных классах (Все тесты успешно пройдены). Написаны консольные приложения:\r\n* пирамидальная сортировка массива, заполняемого случайным образом;\r\n* алгоритм Дейкстры для поиска кратчайших путей от некоторой стартовой вершины связного неориентированного взвешенного графа без петель до всех прочих с использованием приоритетной очереди, основанной на d-куче;\r\n* алгоритм Крускала для построения минимального остовного дерева/леса неориентированного взвешенного графа без петель с использованием приоритетных очередей на базе d-кучи, упорядоченных таблиц и бинарных поисковых деревьев.\r\n\r\n##Литература\r\n1. Кормен Т., Лейзерсон Ч., Риверст Р., Штайн К. Алгоритмы. Построение и анализ. - М.: Издательский дом \"Вильямс\". - 2005. - 1290с.\r\n2. Алексеев В.Е., Таланов В.А. Графы. Модели вычислений. Структуры данных: Учебник. – Нижний Новгород: Изд-во ННГУ, 2005. 307 с.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}